using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RocksDbSharp
{
    public enum AccessHint
    {
        None,
        Normal,
        Sequential,
        WillNeed,
    }

    public class DbOptions : ColumnFamilyOptions
    {
        internal bool CreateIfMissing { get; set; }

        // By default, RocksDB uses only one background thread for flush and
        // compaction. Calling this function will set it up such that total of
        // `total_threads` is used. Good value for `total_threads` is the number of
        // cores. You almost definitely want to call this function if your system is
        // bottlenecked by RocksDB.
        public DbOptions IncreaseParallelism(int totalThreads)
        {
            Native.Instance.rocksdb_options_increase_parallelism(Handle, totalThreads);
            return this;
        }

        // If true, the database will be created if it is missing.
        // Default: false
        public DbOptions SetCreateIfMissing(bool value)
        {
            CreateIfMissing = value; // remember this so that we can change treatment of column families during creation
            Native.Instance.rocksdb_options_set_create_if_missing(Handle, value);
            return this;
        }

        // If true, missing column families will be automatically created.
        // Default: false
        public DbOptions SetCreateMissingColumnFamilies(bool value)
        {
            Native.Instance.rocksdb_options_set_create_missing_column_families(Handle, value);
            return this;
        }

        // If true, an error is raised if the database already exists.
        // Default: false
        public DbOptions SetErrorIfExists(bool value)
        {
            Native.Instance.rocksdb_options_set_error_if_exists(Handle, value);
            return this;
        }

        // If true, RocksDB will aggressively check consistency of the data.
        // Also, if any of the  writes to the database fails (Put, Delete, Merge,
        // Write), the database will switch to read-only mode and fail all other
        // Write operations.
        // In most cases you want this to be set to true.
        // Default: true
        public DbOptions SetParanoidChecks(bool value)
        {
            Native.Instance.rocksdb_options_set_paranoid_checks(Handle, value);
            return this;
        }

        // Use the specified object to interact with the environment,
        // e.g. to read/write files, schedule background work, etc.
        // Default: Env::Default()
        public DbOptions SetEnv(IntPtr env)
        {
            Native.Instance.rocksdb_options_set_env(Handle, env);
            return this;
        }

        // Any internal progress/error information generated by the db will
        // be written to info_log if it is non-nullptr, or to a file stored
        // in the same directory as the DB contents if info_log is nullptr.
        // Default: nullptr
        public DbOptions SetInfoLog(IntPtr logger)
        {
            Native.Instance.rocksdb_options_set_info_log(Handle, logger);
            return this;
        }

        // Number of open files that can be used by the DB.  You may need to
        // increase this if your database has a large working set. Value -1 means
        // files opened are always kept open. You can estimate number of files based
        // on target_file_size_base and target_file_size_multiplier for level-based
        // compaction. For universal-style compaction, you can usually set it to -1.
        // Default: 5000 or ulimit value of max open files (whichever is smaller)
        public DbOptions SetMaxOpenFiles(int value)
        {
            Native.Instance.rocksdb_options_set_max_open_files(Handle, value);
            return this;
        }

        // Once write-ahead logs exceed this size, we will start forcing the flush of
        // column families whose memtables are backed by the oldest live WAL file
        // (i.e. the ones that are causing all the space amplification). If set to 0
        // (default), we will dynamically choose the WAL size limit to be
        // [sum of all write_buffer_size * max_write_buffer_number] * 4
        // Default: 0
        public DbOptions SetMaxTotalWalSize(ulong n)
        {
            Native.Instance.rocksdb_options_set_max_total_wal_size(Handle, n);
            return this;
        }

        public DbOptions EnableStatistics()
        {
            Native.Instance.rocksdb_options_enable_statistics(Handle);
            return this;
        }

        public DbOptions StatisticsGetString()
        {
            Native.Instance.rocksdb_options_statistics_get_string(Handle);
            return this;
        }

        // Maximum number of concurrent background compaction jobs, submitted to
        // the default LOW priority thread pool.
        // We first try to schedule compactions based on
        // `base_background_compactions`. If the compaction cannot catch up , we
        // will increase number of compaction threads up to
        // `max_background_compactions`.
        //
        // If you're increasing this, also consider increasing number of threads in
        // LOW priority thread pool. For more information, see
        // Env::SetBackgroundThreads
        // Default: 1
        public DbOptions SetMaxBackgroundCompactions(int value)
        {
            Native.Instance.rocksdb_options_set_max_background_compactions(Handle, value);
            return this;
        }

        // Maximum number of concurrent background memtable flush jobs, submitted to
        // the HIGH priority thread pool.
        //
        // By default, all background jobs (major compaction and memtable flush) go
        // to the LOW priority pool. If this option is set to a positive number,
        // memtable flush jobs will be submitted to the HIGH priority pool.
        // It is important when the same Env is shared by multiple db instances.
        // Without a separate pool, long running major compaction jobs could
        // potentially block memtable flush jobs of other db instances, leading to
        // unnecessary Put stalls.
        //
        // If you're increasing this, also consider increasing number of threads in
        // HIGH priority thread pool. For more information, see
        // Env::SetBackgroundThreads
        // Default: 1
        public DbOptions SetMaxBackgroundFlushes(int value)
        {
            Native.Instance.rocksdb_options_set_max_background_flushes(Handle, value);
            return this;
        }

        // Specify the maximal size of the info log file. If the log file
        // is larger than `max_log_file_size`, a new info log file will
        // be created.
        // If max_log_file_size == 0, all logs will be written to one
        // log file.
        public DbOptions SetMaxLogFileSize(ulong value)
        {
            Native.Instance.rocksdb_options_set_max_log_file_size(Handle, value);
            return this;
        }

        // Time for the info log file to roll (in seconds).
        // If specified with non-zero value, log file will be rolled
        // if it has been active longer than `log_file_time_to_roll`.
        // Default: 0 (disabled)
        public DbOptions SetLogFileTimeToRoll(ulong value)
        {
            Native.Instance.rocksdb_options_set_log_file_time_to_roll(Handle, value);
            return this;
        }

        // Maximal info log files to be kept.
        // Default: 1000
        public DbOptions SetKeepLogFileNum(ulong value)
        {
            Native.Instance.rocksdb_options_set_keep_log_file_num(Handle, value);
            return this;
        }

        // Recycle log files.
        // If non-zero, we will reuse previously written log files for new
        // logs, overwriting the old data.  The value indicates how many
        // such files we will keep around at any point in time for later
        // use.  This is more efficient because the blocks are already
        // allocated and fdatasync does not need to update the inode after
        // each write.
        // Default: 0
        public DbOptions SetRecycleLogFileNum(ulong value)
        {
            Native.Instance.rocksdb_options_set_recycle_log_file_num(Handle, value);
            return this;
        }

        // manifest file is rolled over on reaching this limit.
        // The older manifest file be deleted.
        // The default value is MAX_INT so that roll-over does not take place.
        public DbOptions SetMaxManifestFileSize(ulong value)
        {
            Native.Instance.rocksdb_options_set_max_manifest_file_size(Handle, value);
            return this;
        }

        // Number of shards used for table cache.
        public DbOptions SetTableCacheNumShardbits(int value)
        {
            Native.Instance.rocksdb_options_set_table_cache_numshardbits(Handle, value);
            return this;
        }

        // DEPRECATED
        [Obsolete]
        public DbOptions SetTableCacheRemoveScanCountLimit(int value)
        {
            Native.Instance.rocksdb_options_set_table_cache_remove_scan_count_limit(Handle, value);
            return this;
        }

        // If true, then every store to stable storage will issue a fsync.
        // If false, then every store to stable storage will issue a fdatasync.
        // This parameter should be set to true while storing data to
        // filesystem like ext3 that can lose files after a reboot.
        // Default: false
        public DbOptions SetUseFsync(int value)
        {
            Native.Instance.rocksdb_options_set_use_fsync(Handle, value);
            return this;
        }

        private string dbLogDir;
        // This specifies the info LOG dir.
        // If it is empty, the log files will be in the same dir as data.
        // If it is non empty, the log files will be in the specified dir,
        // and the db data dir's absolute path will be used as the log file
        // name's prefix.
        public DbOptions SetDbLogDir(string value)
        {
            dbLogDir = value;
            Native.Instance.rocksdb_options_set_db_log_dir(Handle, value);
            return this;
        }

        private string walDir;
        // This specifies the absolute dir path for write-ahead logs (WAL).
        // If it is empty, the log files will be in the same dir as data,
        //   dbname is used as the data dir by default
        // If it is non empty, the log files will be in kept the specified dir.
        // When destroying the db,
        //   all log files in wal_dir and the dir itself is deleted
        public DbOptions SetWalDir(string value)
        {
            walDir = value;
            Native.Instance.rocksdb_options_set_wal_dir(Handle, value);
            return this;
        }

        // The following two fields affect how archived logs will be deleted.
        // 1. If both set to 0, logs will be deleted asap and will not get into
        //    the archive.
        // 2. If WAL_ttl_seconds is 0 and WAL_size_limit_MB is not 0,
        //    WAL files will be checked every 10 min and if total size is greater
        //    then WAL_size_limit_MB, they will be deleted starting with the
        //    earliest until size_limit is met. All empty files will be deleted.
        // 3. If WAL_ttl_seconds is not 0 and WAL_size_limit_MB is 0, then
        //    WAL files will be checked every WAL_ttl_secondsi / 2 and those that
        //    are older than WAL_ttl_seconds will be deleted.
        // 4. If both are not 0, WAL files will be checked every 10 min and both
        //    checks will be performed with ttl being first.
        public DbOptions SetWALTtlSeconds(ulong value)
        {
            Native.Instance.rocksdb_options_set_WAL_ttl_seconds(Handle, value);
            return this;
        }

        // The following two fields affect how archived logs will be deleted.
        // 1. If both set to 0, logs will be deleted asap and will not get into
        //    the archive.
        // 2. If WAL_ttl_seconds is 0 and WAL_size_limit_MB is not 0,
        //    WAL files will be checked every 10 min and if total size is greater
        //    then WAL_size_limit_MB, they will be deleted starting with the
        //    earliest until size_limit is met. All empty files will be deleted.
        // 3. If WAL_ttl_seconds is not 0 and WAL_size_limit_MB is 0, then
        //    WAL files will be checked every WAL_ttl_secondsi / 2 and those that
        //    are older than WAL_ttl_seconds will be deleted.
        // 4. If both are not 0, WAL files will be checked every 10 min and both
        //    checks will be performed with ttl being first.
        public DbOptions SetWALSizeLimitMB(ulong value)
        {
            Native.Instance.rocksdb_options_set_WAL_size_limit_MB(Handle, value);
            return this;
        }

        // Number of bytes to preallocate (via fallocate) the manifest
        // files.  Default is 4mb, which is reasonable to reduce random IO
        // as well as prevent overallocation for mounts that preallocate
        // large amounts of data (such as xfs's allocsize option).
        public DbOptions SetManifestPreallocationSize(ulong value)
        {
            Native.Instance.rocksdb_options_set_manifest_preallocation_size(Handle, value);
            return this;
        }

        // Hint the OS that it should not buffer disk I/O. Enabling this
        // parameter may improve performance but increases pressure on the
        // system cache.
        //
        // The exact behavior of this parameter is platform dependent.
        //
        // On POSIX systems, after RocksDB reads data from disk it will
        // mark the pages as "unneeded". The operating system may - or may not
        // - evict these pages from memory, reducing pressure on the system
        // cache. If the disk block is requested again this can result in
        // additional disk I/O.
        //
        // On WINDOWS system, files will be opened in "unbuffered I/O" mode
        // which means that data read from the disk will not be cached or
        // bufferized. The hardware buffer of the devices may however still
        // be used. Memory mapped files are not impacted by this parameter.
        //
        // Default: true
        public DbOptions SetAllowOsBuffer(bool value)
        {
            Native.Instance.rocksdb_options_set_allow_os_buffer(Handle, value);
            return this;
        }

        // Allow the OS to mmap file for reading sst tables. Default: false
        public DbOptions SetAllowMmapReads(bool value)
        {
            Native.Instance.rocksdb_options_set_allow_mmap_reads(Handle, value);
            return this;
        }

        // Allow the OS to mmap file for writing.
        // DB::SyncWAL() only works if this is set to false.
        // Default: false
        public DbOptions SetAllowMmapWrites(bool value)
        {
            Native.Instance.rocksdb_options_set_allow_mmap_writes(Handle, value);
            return this;
        }

        // Disable child process inherit open files. Default: true
        public DbOptions SetIsFdCloseOnExec(bool value)
        {
            Native.Instance.rocksdb_options_set_is_fd_close_on_exec(Handle, value);
            return this;
        }

        // if not zero, dump rocksdb.stats to LOG every stats_dump_period_sec
        // Default: 600 (10 min)
        public DbOptions SetStatsDumpPeriodSec(uint value)
        {
            Native.Instance.rocksdb_options_set_stats_dump_period_sec(Handle, value);
            return this;
        }

        // If set true, will hint the underlying file system that the file
        // access pattern is random, when a sst file is opened.
        // Default: true
        public DbOptions SetAdviseRandomOnOpen(bool value)
        {
            Native.Instance.rocksdb_options_set_advise_random_on_open(Handle, value);
            return this;
        }

        // Specify the file access pattern once a compaction is started.
        // It will be applied to all input files of a compaction.
        // Default: NORMAL
        public DbOptions SetAccessHintOnCompactionStart(int value)
        {
            Native.Instance.rocksdb_options_set_access_hint_on_compaction_start(Handle, value);
            return this;
        }

        // Use adaptive mutex, which spins in the user space before resorting
        // to kernel. This could reduce context switch when the mutex is not
        // heavily contended. However, if the mutex is hot, we could end up
        // wasting spin time.
        // Default: false
        public DbOptions SetUseAdaptiveMutex(bool value)
        {
            Native.Instance.rocksdb_options_set_use_adaptive_mutex(Handle, value);
            return this;
        }

        // Allows OS to incrementally sync files to disk while they are being
        // written, asynchronously, in the background. This operation can be used
        // to smooth out write I/Os over time. Users shouldn't reply on it for
        // persistency guarantee.
        // Issue one request for every bytes_per_sync written. 0 turns it off.
        // Default: 0
        //
        // You may consider using rate_limiter to regulate write rate to device.
        // When rate limiter is enabled, it automatically enables bytes_per_sync
        // to 1MB.
        //
        // This option applies to table files
        public DbOptions SetBytesPerSync(ulong value)
        {
            Native.Instance.rocksdb_options_set_bytes_per_sync(Handle, value);
            return this;
        }

        // If true, then the contents of manifest and data files are not synced
        // to stable storage. Their contents remain in the OS buffers till the
        // OS decides to flush them. This option is good for bulk-loading
        // of data. Once the bulk-loading is complete, please issue a
        // sync to the OS to flush all dirty buffesrs to stable storage.
        // Default: false
        public DbOptions SetDisableDataSync(int value)
        {
            Native.Instance.rocksdb_options_set_disable_data_sync(Handle, value);
            return this;
        }

        // The periodicity when obsolete files get deleted. The default
        // value is 6 hours. The files that get out of scope by compaction
        // process will still get automatically delete on every compaction,
        // regardless of this setting
        public DbOptions SetDeleteObsoleteFilesPeriodMicros(ulong value)
        {
            Native.Instance.rocksdb_options_set_delete_obsolete_files_period_micros(Handle, value);
            return this;
        }

        // Set appropriate parameters for bulk loading.
        // The reason that this is a function that returns "this" instead of a
        // constructor is to enable chaining of multiple similar calls in the future.
        //
        // All data will be in level 0 without any automatic compaction.
        // It's recommended to manually call CompactRange(NULL, NULL) before reading
        // from the database, because otherwise the read can be very slow.
        public DbOptions PrepareForBulkLoad()
        {
            Native.Instance.rocksdb_options_prepare_for_bulk_load(Handle);
            return this;
        }

    }
}
